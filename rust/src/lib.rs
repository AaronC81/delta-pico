#![no_std]
#![feature(default_alloc_error_handler)]

extern crate alloc;

mod c_allocator;

use core::{panic::PanicInfo, cell::RefCell};
use alloc::{format, string::String, vec::Vec, vec, rc::Rc};
use c_allocator::CAllocator;

mod interface;
mod operating_system;
mod rbop_impl;
mod applications;
mod filesystem;
mod timer;
mod multi_tap;

use fatfs::{FileSystem, FsOptions, Write, IoBase, Read, Seek};
use interface::framework;
use operating_system::os;

use crate::{interface::Colour, operating_system::{OSInput, OperatingSystemInterface}};

#[global_allocator]
static ALLOCATOR: CAllocator = CAllocator;

#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    framework().display.switch_to_screen();
    framework().display.fill_screen(Colour::BLACK);

    // Draw panic title bar
    framework().display.draw_rect(
        0, 0, framework().display.width as i64, OperatingSystemInterface::TITLE_BAR_HEIGHT,
        Colour::RED, interface::ShapeFill::Filled, 0,
    );
    framework().display.print_at(5, 7, "Panic   :(");

    // Draw error text
    let (lines, line_height, _) =
        framework().display.wrap_text(&format!("{}", info), framework().display.width as i64 - 20);
    for (i, line) in lines.iter().enumerate() {
        framework().display.print_at(
            10, OperatingSystemInterface::TITLE_BAR_HEIGHT + 5 + line_height * i as i64,
            line
        );
    }

    // Draw keys
    framework().display.print_at(
        0, framework().display.height as i64 - 50, "Restart the device, or use\n[EXE] to enter bootloader"
    );
    
    framework().display.draw();

    loop {
        if let Some(OSInput::Exe) = framework().buttons.wait_press() {
            os().reboot_into_bootloader();
        }
    }
}

fn debug(info: String) {
    let mut message_bytes = info.as_bytes().iter().cloned().collect::<Vec<_>>();
    message_bytes.push(0);

    (framework().debug_handler)(message_bytes.as_ptr());
}

struct VecFS {
    vec: Rc<RefCell<Vec<u8>>>,
    ptr: usize,
}

impl IoBase for VecFS {
    type Error = ();
}

impl Write for VecFS {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Error> {
        for i in 0..buf.len() {
            self.vec.borrow_mut()[self.ptr] = buf[i];
            self.ptr += 1;
        }

        Ok(buf.len())
    }

    fn flush(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

impl Read for VecFS {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, Self::Error> {
        for i in 0..buf.len() {
            buf[i] = self.vec.borrow_mut()[self.ptr];
            self.ptr += 1;
        }

        Ok(buf.len())
    }
}

impl Seek for VecFS {
    fn seek(&mut self, pos: fatfs::SeekFrom) -> Result<u64, Self::Error> {
        match pos {
            fatfs::SeekFrom::Start(x) => self.ptr = x as usize,
            fatfs::SeekFrom::End(x) => self.ptr = self.vec.borrow().len() + x as usize - 1,
            fatfs::SeekFrom::Current(x) => self.ptr += x as usize,
        }
        Ok(self.ptr as u64)
    }
}

#[no_mangle]
pub extern "C" fn delta_pico_main() {
    debug("Rust main!".into());

    os().application_list.add::<applications::calculator::CalculatorApplication>();
    os().application_list.add::<applications::graph::GraphApplication>();
    os().application_list.add::<applications::tetris::TetrisApplication>();
    os().application_list.add::<applications::numbers_game::NumbersGame>();
    os().application_list.add::<applications::about::AboutApplication>();
    os().application_list.add::<applications::settings::SettingsApplication>();
    os().application_list.add::<applications::storage::StorageApplication>();
    os().application_list.add::<applications::bootloader::BootloaderApplication>();

    if !(framework().storage.connected)() {
        os().ui_text_dialog("Unable to communicate with storage.");
    }


    //TODO: Temporary
    let block_num = framework().usb_mass_storage.block_num;
    let block_size = framework().usb_mass_storage.block_size;

    let mut fat12_fs = vec![0u8; block_num * block_size];

    // Add boot sector
    let boot_sector = [
        0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00,
        0x01, 0x10, 0x00, 0x10, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, b'D' , b'e' , b'l' , b't' , b'a' ,
        b' ' , b'P' , b'i' , b'c' , b'o' , b' ' , 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00,

        // Zero up to 2 last bytes of FAT magic code
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
    ];
    fat12_fs.splice(0..(block_size - 1), boot_sector);

    // Add FAT12 file allocation table
    fat12_fs.splice(block_size..(block_size * 2 - 1), [0xF8, 0xFF, 0xFF, 0xFF, 0x0F]);

    // Add volume label and root directory
    let readme =
        "Your Delta Pico is mounted as USB flash storage. Eject the drive in your OS once done!";
    fat12_fs.splice((block_size * 2)..(block_size * 3 - 1), [
        b'D' , b'e' , b'l' , b't' , b'a' , b' ' , b'P' , b'i' , b'c' , b'o' , b' ' , 0x08, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // second entry is readme file
        b'R' , b'E' , b'A' , b'D' , b'M' , b'E' , b' ' , b' ' , b'T' , b'X' , b'T' , 0x20, 0x00, 0xC6, 0x52, 0x6D,
        0x65, 0x43, 0x65, 0x43, 0x00, 0x00, 0x88, 0x6D, 0x65, 0x43, 0x02, 0x00,
        readme.len() as u8, 0x00, 0x00, 0x00
    ]);

    // Add README.txt file content
    fat12_fs.splice((block_size * 3)..(block_size * 4 - 1), readme.as_bytes().iter().copied());

    let fat12_fs = Rc::new(RefCell::new(fat12_fs));
    let wrapper = VecFS { vec: fat12_fs.clone(), ptr: 0 };
    let fs = FileSystem::new(wrapper, FsOptions::new()).unwrap();
    fs.root_dir().create_file("test.txt").unwrap().write(&[b'w']).unwrap();

    framework().usb_mass_storage.fat12_filesystem = fat12_fs.borrow_mut().as_mut_ptr();


    loop {
        os().application_to_tick().tick();
    }
}
